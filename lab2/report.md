# Отчёт по программе синтаксического анализа операторов цикла `while (...) ... done`

## Введение

Цель данной программы — разработать лексический и синтаксический анализаторы для языка, содержащего операторы цикла вида `while (...) ... done`, разделённые символом `;`. Программа должна принимать текст на этом языке, выполнять лексический анализ (разбиение на токены), синтаксический анализ (проверку структуры) и строить дерево разбора (AST). Для реализации выбран язык программирования C++ с использованием современных стандартов и средств автоматизации сборки (Makefile).

Дерево разбора (AST):

```
Program
  StatementList
    WhileLoop
      Condition
        Identifier (x)
        RelOp (<)
        RomanNumeral (V)
      Assignment
        LValue (y)
        RomanNumeral (I)
```

## Основные задачи разработки

1. **Разработка лексического анализатора**, распознающего ключевые слова (`while`, `done`), идентификаторы, римские числа (записанные заглавными `I`, `V`, `X`), операторы сравнения (`<`, `>`, `=`), присваивания (`:=`) и разделителя (`;`).

2. **Реализация синтаксического анализатора** на основе грамматики:
```
Program      → StatementList
StatementList→ Statement (';' Statement)*
Statement    → while '(' Condition ')' Body done
Condition    → Expression RelOp Expression
Body         → Assignment
Assignment   → IDENTIFIER ':=' Expression
Expression   → IDENTIFIER | ROMAN_NUMERAL
RelOp        → '<' | '>' | '='
```

3. **Построение и вывод дерева абстрактного синтаксиса (AST)** для визуальной проверки корректности разбора.

4. **Создание Makefile**, обеспечивающего автоматическую сборку и запуск программы с пересборкой при каждом вызове.

5. **Обеспечение читаемости кода** с краткой документацией ко всем компонентам.

## Алгоритм решения

Программа выполняет два основных этапа:

- **Лексический анализ**: входная строка сканируется посимвольно. Распознаются ключевые слова, символы и лексемы. Слова из букв `I`, `V`, `X` интерпретируются как римские числа, остальные — как идентификаторы.
  
- **Синтаксический анализ**: на основе потока токенов рекурсивным спуском строится AST. Каждый узел дерева соответствует конструкции языка (цикл, условие, присваивание и т.д.).

Структура основной функции:
```cpp
int main() {
    // Загружает тестовые строки
    // Для каждой: tokenize → Parser → printAST
}
```

Функция `tokenize` возвращает вектор токенов. Класс `Parser` строит AST. Функция `printAST` выводит дерево с отступами.

## Особенности реализации

- Римские числа определяются как **любые непустые строки**, состоящие **только** из заглавных `I`, `V`, `X`.
- Идентификаторы — любые альфанумерические последовательности, не являющиеся римскими числами.
- Тело цикла ограничено **одним присваиванием** — это упрощает грамматику.
- При синтаксической ошибке программа завершается с сообщением (достаточно для лабораторной работы).
- Используется `std::shared_ptr` для безопасного управления памятью AST.

Код снабжён краткими комментариями ко всем функциям и полям, что обеспечивает понимание без внешней документации.

## Makefile

Для упрощения сборки и запуска используется следующий Makefile:

```makefile
TARGET = main.exe
CXX = g++
CXXFLAGS = -Wall -std=c++17
SRC = main.cpp

all: clean $(TARGET)
	./$(TARGET)

$(TARGET): $(SRC)
	$(CXX) $(CXXFLAGS) $(SRC) -o $(TARGET)

clean:
	rm -f $(TARGET)
```

Использование:
1. Команда `make` выполняет полную пересборку и запускает программу.
2. Цель `clean` удаляет старый исполняемый файл, гарантируя актуальную сборку.

Это обеспечивает удобство тестирования и отладки.

## Тестирование и применение

Программа протестирована на следующих входных данных:

```text
while (x < V) y := I done
while (a = I) b := X done; while (n > III) m := a done
```

Для первой строки строится AST вида:
```text
Program
  StatementList
    WhileLoop
      Condition
        Identifier (x)
        RelOp (<)
        RomanNumeral (V)
      Assignment
        LValue (y)
        RomanNumeral (I)
```

Также проверена реакция на ошибки (пропущенное `done`, неверный оператор и т.д.) — программа корректно завершается с диагностикой.

![alt text](image.png)

## Заключение

Реализованная программа успешно решает задачу синтаксического анализа заданного языка. Архитектура «лексер → парсер → AST» соответствует классическим принципам построения компиляторов и может быть расширена для поддержки более сложных конструкций (блоков, выражений, семантического анализа). Использование Makefile автоматизирует процесс сборки и тестирования, а читаемый код с документацией обеспечивает поддерживаемость. Проект демонстрирует понимание основ лексического и синтаксического анализа и может служить основой для дальнейшего изучения теории компиляторов.
