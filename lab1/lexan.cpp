#include <iostream>
#include <string>
#include<vector>

using namespace std; 
/**
 * Функция dfaOddConsecutive реализует детерминированный конечный автомат (DFA),
 * который проверяет строку на наличие подцепочек с нечётным количеством подряд идущих '1' и '0'.
 * 
 * Данный автомат построен на принципе подсчёта максимально длинных последовательных блоков единиц и нулей,
 * и проверяет, чтобы эти максимальные длины были нечётными.
 * 
 * @param str Входная строка, состоящая из символов '0' и '1'.
 * @return true, если в строке есть подцепочки с нечётным числом подряд идущих единиц и нулей.
 *         false, если условие не выполнено или в строке есть недопустимые символы.
 */
bool dfaOddConsecutive(const std::string& str) {
    // Счётчик для текущей последовательности единиц
    int countOne = 0;
    // Счётчик для текущей последовательности нулей
    int countZero = 0;
    // Максимальная длина подряд идущих единиц во всей строке
    int maxOne = 0;
    // Максимальная длина подряд идущих нулей во всей строке
    int maxZero = 0;
    // Последний обработанный символ
    char last = '\0';

    // Проходим по каждому символу строки
    for (char c : str) {
        if (c == '1') {
            // Если текущий символ равен '1' и предыдущий тоже '1' – увеличиваем счётчик подряд идущих единиц
            if (last == '1') {
                countOne++;
            } else {
                // Иначе начинаем новый подсчёт одиниц
                countOne = 1;
            }
            // Обновляем максимальную длину подряд идущих единиц
            maxOne = std::max(maxOne, countOne);
            // Сбрасываем счётчик нулей, так как текущий символ '1'
            countZero = 0;
        } else if (c == '0') {
            // Аналогично для нулей
            if (last == '0') {
                countZero++;
            } else {
                countZero = 1;
            }
            maxZero = std::max(maxZero, countZero);
            countOne = 0;
        } else {
            // Если встречен недопустимый символ — сразу возвращаем false
            return false;
        }
        last = c; // Запоминаем текущий символ как последний
    }

    // Возвращаем true только если максимальная длина подряд идущих единиц и нулей — нечетная
    return (maxOne % 2 == 1) && (maxZero % 2 == 1);
}
struct TestCase {
        std::string input;
        bool expected;
        std::string description;
    };


int main() {

    std::vector<TestCase> tests = {
        {"11", false, "Две '1' — чётная длина, нет нечётных блоков"},
        {"00", false, "Два '0' — чётная длина"},
        {"1100", false, "Все блоки чётной длины"},
        {"1010", true, "Каждый блок длины 1 — нечётный"},
        {"110011", false, "Все блоки длины 2 — чётные"},
        {"111000111", true, "Блоки длины 3 — нечётные"},
        {"1111", false, "Блок длины 4 — чётный"},
        {"", false, "Пустая строка"},
        {"10101", true, "Все блоки длины 1 — нечётные"},
        {"0011", false, "Все блоки чётной длины"},
        {"abc101def", true, "С посторонними символами (после фильтрации остаётся '101')"}
    };

    int passed = 0;
    int total = tests.size();

    for (const auto& test_case : tests) {
        // Фильтруем только '0' и '1'
        std::string filtered;
        for (char c : test_case.input) {
            if (c == '0' || c == '1') {
                filtered += c;
            }
        }

        bool result = dfaOddConsecutive(filtered);
        bool success = (result == test_case.expected);

        std::cout << (success ? "[ПРОЙДЕН] " : "[ОШИБКА] ")
                  << test_case.description << " -> "
                  << "отфильтровано: \"" << filtered << "\", получено: " << (result ? "да" : "нет")
                  << ", ожидалось: " << (test_case.expected ? "да" : "нет") << "\n";

        if (success) passed++;
    }

    std::cout << "\nПройдено тестов: " << passed << " из " << total << "\n";
    return 0;
}