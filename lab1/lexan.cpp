#include <iostream>
#include <string>

/**
 * Функция dfaOddConsecutive реализует детерминированный конечный автомат (DFA),
 * который проверяет строку на наличие подцепочек с нечётным количеством подряд идущих '1' и '0'.
 * 
 * Данный автомат построен на принципе подсчёта максимально длинных последовательных блоков единиц и нулей,
 * и проверяет, чтобы эти максимальные длины были нечётными.
 * 
 * @param str Входная строка, состоящая из символов '0' и '1'.
 * @return true, если в строке есть подцепочки с нечётным числом подряд идущих единиц и нулей.
 *         false, если условие не выполнено или в строке есть недопустимые символы.
 */
bool dfaOddConsecutive(const std::string& str) {
    // Счётчик для текущей последовательности единиц
    int countOne = 0;
    // Счётчик для текущей последовательности нулей
    int countZero = 0;
    // Максимальная длина подряд идущих единиц во всей строке
    int maxOne = 0;
    // Максимальная длина подряд идущих нулей во всей строке
    int maxZero = 0;
    // Последний обработанный символ
    char last = '\0';

    // Проходим по каждому символу строки
    for (char c : str) {
        if (c == '1') {
            // Если текущий символ равен '1' и предыдущий тоже '1' – увеличиваем счётчик подряд идущих единиц
            if (last == '1') {
                countOne++;
            } else {
                // Иначе начинаем новый подсчёт одиниц
                countOne = 1;
            }
            // Обновляем максимальную длину подряд идущих единиц
            maxOne = std::max(maxOne, countOne);
            // Сбрасываем счётчик нулей, так как текущий символ '1'
            countZero = 0;
        } else if (c == '0') {
            // Аналогично для нулей
            if (last == '0') {
                countZero++;
            } else {
                countZero = 1;
            }
            maxZero = std::max(maxZero, countZero);
            countOne = 0;
        } else {
            // Если встречен недопустимый символ — сразу возвращаем false
            return false;
        }
        last = c; // Запоминаем текущий символ как последний
    }

    // Возвращаем true только если максимальная длина подряд идущих единиц и нулей — нечетная
    return (maxOne % 2 == 1) && (maxZero % 2 == 1);
}

int main() {
    // Исходная строка с возможными недопустимыми символами
    std::string test = "2000111000000111";

    // Фильтрация строки: сохраняем только символы '0' и '1'
    std::string filtered;
    for (char c : test) 
        if (c == '0' || c == '1') 
            filtered += c;

    // Вывод результата проверки
    if (dfaOddConsecutive(filtered)) {
        std::cout << "Строка содержит нечетное число подряд идущих единиц и нулей\n";
    } else {
        std::cout << "Условие не выполнено\n";
    }
    return 0;
}
